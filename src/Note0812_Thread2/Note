1、线程这块还有哪些内容呢？列举一下
    1.1、守护线程
        java语言中线程分为两大类：
            一类是：用户线程
            一类是：守护线程（后台线程）
            其中具有代表性的就是：垃圾回收线程（守护线程）。
        守护线程的特点：
            一般守护线程是一个死循环，所有的用户线程只要结束，
            守护线程自动结束。
        注意：主线程main方法是一个用户线程。

        守护线程用在什么地方呢？
            每天00:00的时候系统数据自动备份。
            这个需要使用到定时器，并且我们可以将定时器设置为守护线程。
            一直在那里看着，每到00:00的时候就备份一次。所有的用户线程
            如果结束了，守护线程自动退出，没有必要进行数据备份了。

    1.2、定时器
        定时器的作用：
            间隔特定的时间，执行特定的程序。
            每周要进行银行账户的总账操作。
            每天要进行数据的备份操作。

            在实际的开发中，每隔多久执行一段特定的程序，这种需求是很常见的，
            那么在java中其实可以采用多种方式实现：
                可以使用sleep方法，睡眠，设置睡眠时间，每到这个时间点醒来，执行
                任务。这种方式是最原始的定时器。（比较low）

                在java的类库中已经写好了一个定时器：java.util.Timer，可以直接拿来用。
                不过，这种方式在目前的开发中也很少用，因为现在有很多高级框架都是支持
                定时任务的。

                在实际的开发中，目前使用较多的是Spring框架中提供的SpringTask框架，
                这个框架只要进行简单的配置，就可以完成定时器的任务。



    1.3、实现线程的第三种方式：FutureTask方式，实现Callable接口。（JDK8新特性。）
        这种方式实现的线程可以获取线程的返回值。
        之前讲解的那两种方式是无法获取线程返回值的，因为run方法返回void。

        思考：
            系统委派一个线程去执行一个任务，该线程执行完任务之后，可能会有一个执行结果，我们怎么能拿到这个执行结果呢？
                使用第三种方式：实现Callable接口方式。

    1.4、关于Object类中的wait和notify方法。（生产者和消费者模式！）

        第一：wait和notify方法不是线程对象的方法，是java中任何一个java对象
        都有的方法，因为这两个方法是Object类中自带的。
            wait方法和notify方法不是通过线程对象调用，
            不是这样的:t.wait(),也不是这样的:t.notify()...不对。

        第二:wait()方法作用？
            Object o = new Object();
            o.wait();
            表示：
                让正在o对象上活动的线程进入等待状态，无期限等待，
                直到被唤醒为止。
                o.wait();方法的调用，会让"当前线程(正在o对象上活动搞得线程)"
                进入等待状态。

        第三：notify()方法作用？
            Object o = new Object();
            o.notify();

            表示：
                唤醒正在o对象上等待的线程。
            还有一个notifyAll()方法：
                这个方法是唤醒o对象上处于等待的所有线程。


